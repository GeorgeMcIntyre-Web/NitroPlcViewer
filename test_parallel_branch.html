<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parallel Branch Test Verification</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        canvas {
            border: 2px solid green;
            margin: 10px 0;
        }
        button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #1d4ed8;
        }
        .verification {
            background: #f0f9ff;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #2563eb;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>Parallel Branch Layout Verification</h1>
    
    <div class="verification">
        <h3>âœ… Layout Improvements Applied:</h3>
        <ul>
            <li><strong>Longer Start Line:</strong> Increased from 80px to 120px from left power rail</li>
            <li><strong>Shorter End Line:</strong> Reduced merge junction spacing from 120px to 80px</li>
            <li><strong>Compact Branch:</strong> Reduced vertical drop from 80px to 60px</li>
            <li><strong>Tighter Spacing:</strong> Reduced parallel path spacing from 80px to 60px</li>
            <li><strong>Better Balance:</strong> Optimized split junction spacing for visual harmony</li>
        </ul>
    </div>
    
    <div class="test-container">
        <h2>Parallel Branch Test</h2>
        <button onclick="testParallelBranch()">Test Parallel Branch Layout</button>
        <div id="parallel-branch-test"></div>
    </div>

    <script>
        // Copy the essential functions from test_ladder.html
        function log(message) {
            console.log(message);
        }

        function testParallelBranch() {
            console.log('=== PARALLEL BRANCH LAYOUT TEST ===');
            
            const testRung = {
                text: 'XIC(Start_Button) [XIC(Proximity_Sensor) | XIO(Emergency_Stop)] OTE(Motor_Output)'
            };
            
            renderRung(testRung, 'parallel-branch-test', 800, 300);
            console.log('=== PARALLEL BRANCH LAYOUT TEST COMPLETE ===');
        }

        function renderRung(rung, containerId, width, height) {
            // Validate inputs
            if (!rung || !rung.text || !containerId) {
                log('ERROR: Invalid rung or container parameters');
                return;
            }
            
            // Validate dimensions
            width = Math.max(width || 800, 400);
            height = Math.max(height || 300, 150);
            
            console.log('Rendering rung: ' + rung.text);
            
            const container = document.getElementById(containerId);
            if (!container) {
                log('ERROR: Container element not found: ' + containerId);
                return;
            }
            
            container.innerHTML = '';
            
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            canvas.style.border = '2px solid green';
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                log('ERROR: Could not get canvas context');
                return;
            }
            
            console.log('Canvas created: ' + canvas.width + 'x' + canvas.height);
            
            try {
                // Clear with white background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Parse the rung with branch detection
                const parsedRung = parseRungLogic(rung.text);
                console.log('Parsed rung structure:', parsedRung);
                
                // Calculate layout
                const layout = calculateLayout(parsedRung, width, height);
                if (!layout) {
                    log('ERROR: Layout calculation failed');
                    return;
                }
                console.log('Layout calculated:', layout);
                
                // Draw power rails
                drawPowerRails(ctx, width, height);
                
                // Draw all branches and elements
                drawBranches(ctx, parsedRung, layout);
                
                container.appendChild(canvas);
                console.log('Canvas added to page');
                
            } catch (error) {
                log('ERROR in renderRung: ' + error.message);
                // Draw error indication on canvas
                ctx.fillStyle = '#ff0000';
                ctx.font = '16px Arial';
                ctx.fillText('Error rendering rung', 10, 30);
            }
        }

        // Include all the necessary functions from test_ladder.html
        function parseRungLogic(rungText) {
            console.log('Parsing rung text: ' + rungText);
            
            const tokens = rungText.split(/(\s+|[\[\]|])/).filter(token => token.trim() && token !== ' ');
            console.log('Tokens:', tokens);
            
            const rung = {
                inputs: { elements: [] },
                outputs: { elements: [] },
                parallelBranches: [],
                junctions: []
            };
            
            let currentBranch = rung.inputs;
            let branchStack = [rung.inputs];
            let currentLevel = 0;
            let currentParallelBranch = null;
            
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i].trim();
                
                if (token === '[') {
                    currentLevel++;
                    currentParallelBranch = { 
                        level: currentLevel, 
                        paths: [[]],
                        parent: currentBranch,
                        splitPoint: null,
                        mergePoint: null
                    };
                    
                    const junction = {
                        type: 'split',
                        x: 0,
                        y: 0,
                        parentBranch: currentBranch,
                        parallelBranch: currentParallelBranch
                    };
                    
                    rung.parallelBranches.push(currentParallelBranch);
                    rung.junctions.push(junction);
                    branchStack.push(currentParallelBranch);
                    currentBranch = currentParallelBranch;
                    
                } else if (token === '|') {
                    if (currentParallelBranch) {
                        currentParallelBranch.paths.push([]);
                    }
                    
                } else if (token === ']') {
                    const parallelBranch = currentBranch;
                    const parentBranch = branchStack[branchStack.length - 2];
                    
                    const junction = {
                        type: 'merge',
                        x: 0,
                        y: 0,
                        parentBranch: parentBranch,
                        parallelBranch: parallelBranch
                    };
                    
                    rung.junctions.push(junction);
                    branchStack.pop();
                    currentBranch = parentBranch;
                    currentLevel--;
                    currentParallelBranch = null;
                    
                } else if (token) {
                    const instructionMatch = token.match(/([A-Z]{2,4})\(([^)]+)\)/);
                    if (instructionMatch) {
                        const instruction = instructionMatch[1];
                        const tag = instructionMatch[2];
                        
                        const element = {
                            type: getElementType(instruction),
                            instruction: instruction,
                            tag: tag,
                            width: calculateElementWidth(instruction, tag),
                            height: getElementHeight(instruction)
                        };
                        
                        if (['OTE', 'OTL', 'OTU'].includes(instruction)) {
                            rung.outputs.elements.push(element);
                        } else {
                            if (currentParallelBranch) {
                                currentParallelBranch.paths[currentParallelBranch.paths.length - 1].push(element);
                            } else {
                                currentBranch.elements.push(element);
                            }
                        }
                    }
                }
            }
            
            return rung;
        }

        function calculateLayout(rungStructure, canvasWidth, canvasHeight) {
            // Validate inputs
            if (!rungStructure || !canvasWidth || !canvasHeight) {
                log('ERROR: Invalid parameters passed to calculateLayout');
                return null;
            }
            
            // Validate dimensions
            canvasWidth = Math.max(canvasWidth || 800, 400);
            canvasHeight = Math.max(canvasHeight || 300, 150);
            
            const layout = {
                inputs: { elements: [], y: 100 },
                outputs: { elements: [], y: 100 },
                parallelBranches: [],
                junctions: [],
                powerRailLeft: 20,
                powerRailRight: canvasWidth - 20
            };
            
            let currentX = 120; // Longer start line
            const elementSpacing = 40;
            const mainLineY = 100;
            
            rungStructure.inputs.elements.forEach(element => {
                element.x = Math.round(currentX);
                element.y = Math.round(mainLineY);
                element.branchType = 'input';
                layout.inputs.elements.push(element);
                currentX += element.width + elementSpacing;
            });
            
            const splitX = layout.inputs.elements.length > 0 ? 
                layout.inputs.elements[layout.inputs.elements.length - 1].x + 120 :
                200;

            if (rungStructure.outputs.elements.length > 0) {
                const totalOutputWidth = rungStructure.outputs.elements.reduce((sum, element) => sum + element.width, 0);
                const totalSpacing = (rungStructure.outputs.elements.length - 1) * elementSpacing;
                const totalRequiredWidth = totalOutputWidth + totalSpacing + 40;
                
                const mergeJunctionX = splitX + 120 + 20; // Further reduced for much closer parallel branch ending
                const minOutputStartX = mergeJunctionX + 40; // Reduced from 80 to 40
                const rightAlignedOutputX = canvasWidth - 40 - totalRequiredWidth; // Position outputs much closer to right power rail (40px from rail)
                
                let currentOutputX = Math.max(minOutputStartX, rightAlignedOutputX);
                
                rungStructure.outputs.elements.forEach(element => {
                    element.x = Math.round(currentOutputX);
                    element.y = Math.round(mainLineY);
                    element.branchType = 'output';
                    layout.outputs.elements.push(element);
                    currentOutputX += element.width + elementSpacing;
                });
            }
            
            // ENHANCED PARALLEL BRANCH POSITIONING
            rungStructure.parallelBranches.forEach((parallelBranch, index) => {
                const branchLayout = {
                    paths: [],
                    level: parallelBranch.level,
                    splitX: splitX // Common split position for all parallel branches
                };
                
                // Calculate spacing for multiple paths with proper bounds checking
                const pathSpacing = Math.max(60, 40 + (parallelBranch.paths.length * 5)); // Dynamic spacing
                const totalPaths = parallelBranch.paths.length;
                const baseOffset = totalPaths > 1 ? 80 : 60; // More space for multiple paths
                const startY = mainLineY + baseOffset;
                
                // Position each path with validation
                parallelBranch.paths.forEach((path, pathIndex) => {
                    const pathLayout = {
                        elements: [],
                        y: startY + pathIndex * pathSpacing
                    };
                    
                    // CRITICAL FIX: Position elements to hug the split
                    let pathX = splitX + 8; // Minimal gap from split (was 20)
                    
                    path.forEach((element, elementIndex) => {
                        // Validate element exists and has required properties
                        if (!element || !element.instruction) {
                            log(`WARNING: Invalid element at path ${pathIndex}, element ${elementIndex}`);
                            return;
                        }
                        
                        element.x = Math.round(pathX);
                        element.y = Math.round(pathLayout.y);
                        element.branchType = 'parallel';
                        element.branchLevel = parallelBranch.level;
                        element.pathIndex = pathIndex;
                        element.splitX = splitX; // Pass splitX for tag positioning
                        element.elementIndex = elementIndex; // Track position within path
                        
                        // Add validation for width calculation
                        if (!element.width) {
                            element.width = calculateElementWidth(element.instruction, element.tag || '');
                        }
                        
                        pathLayout.elements.push(element);
                        
                        // Space elements properly within the path
                        const elementSpacing = Math.max(40, element.width + 20);
                        pathX += elementSpacing;
                    });
                    
                    branchLayout.paths.push(pathLayout);
                });
                
                layout.parallelBranches.push(branchLayout);
            });
            
            let splitJunctions = rungStructure.junctions.filter(j => j.type === 'split');
            let mergeJunctions = rungStructure.junctions.filter(j => j.type === 'merge');
            
            splitJunctions.forEach((junction, index) => {
                junction.x = Math.round(splitX);
                junction.y = Math.round(mainLineY);
                layout.junctions.push(junction);
            });
            
            mergeJunctions.forEach((junction, index) => {
                junction.y = Math.round(mainLineY);
                layout.junctions.push(junction);
            });
            
            layout.parallelBranches.forEach((branch, branchIndex) => {
                const mergeJunction = mergeJunctions[branchIndex];
                if (mergeJunction) {
                    mergeJunction.x = Math.round(splitX + 120 + 20); // Match the mergeJunctionX calculation
                }
            });
            
            layout.parallelBranches.forEach((branch, branchIndex) => {
                if (branch.paths.length > 0) {
                    const splitJunction = splitJunctions[branchIndex];
                    const mergeJunction = mergeJunctions[branchIndex];
                    
                    if (splitJunction) {
                        splitJunction.parallelBranch = rungStructure.parallelBranches[branchIndex];
                        const firstPath = branch.paths[0];
                        if (firstPath && firstPath.elements.length > 0) {
                            const firstElement = firstPath.elements[0];
                            splitJunction.parallelStartX = firstElement.x - firstElement.width / 2;
                            splitJunction.parallelStartY = firstPath.y;
                        }
                    }
                    
                    if (mergeJunction) {
                        mergeJunction.parallelBranch = rungStructure.parallelBranches[branchIndex];
                        const lastPath = branch.paths[branch.paths.length - 1];
                        if (lastPath && lastPath.elements.length > 0) {
                            const lastElement = lastPath.elements[lastPath.elements.length - 1];
                            mergeJunction.parallelEndX = lastElement.x + lastElement.width / 2;
                            mergeJunction.parallelEndY = lastPath.y;
                        }
                    }
                }
            });
            
            return layout;
        }

        function drawPowerRails(ctx, width, height) {
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(20, 20);
            ctx.lineTo(20, height - 20);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(width - 20, 20);
            ctx.lineTo(width - 20, height - 20);
            ctx.stroke();
        }

        function drawBranches(ctx, rungStructure, layout) {
            drawPowerRailConnections(ctx, layout);
            
            ctx.strokeStyle = '#6b7280';
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(layout.powerRailLeft, layout.inputs.y);
            ctx.lineTo(layout.powerRailRight, layout.inputs.y);
            ctx.stroke();
            
            const allElements = [
                ...layout.inputs.elements,
                ...layout.outputs.elements,
                ...layout.parallelBranches.flatMap(branch => branch.paths.flatMap(path => path.elements))
            ];
            
            allElements.forEach(element => {
                if (element.type === 'contact') {
                    drawContact(ctx, element.x, element.y, element.instruction, element.tag, element);
                } else if (element.type === 'coil') {
                    drawCoil(ctx, element.x, element.y, element.instruction, element.tag);
                } else if (element.type === 'function') {
                    drawFunctionBlock(ctx, element.x, element.y, element.instruction, element.tag);
                }
            });
            
            [layout.inputs, layout.outputs].forEach(branch => {
                for (let i = 0; i < branch.elements.length - 1; i++) {
                    const current = branch.elements[i];
                    const next = branch.elements[i + 1];
                    
                    ctx.strokeStyle = '#6b7280';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    
                    const startX = Math.round(current.x + current.width / 2);
                    const endX = Math.round(next.x - next.width / 2);
                    const y = Math.round(branch.y);
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                    ctx.stroke();
                }
            });
            
            // ENHANCED PARALLEL BRANCH CONNECTION DRAWING
            layout.parallelBranches.forEach((branch, branchIndex) => {
                if (!branch.paths || branch.paths.length === 0) {
                    log(`WARNING: Branch ${branchIndex} has no paths`);
                    return;
                }
                
                // Find corresponding junctions with validation
                const splitJunction = layout.junctions.find(j => j.type === 'split' && j.parallelBranch && j.parallelBranch.level === branch.level);
                const mergeJunction = layout.junctions.find(j => j.type === 'merge' && j.parallelBranch && j.parallelBranch.level === branch.level);
                
                if (!splitJunction || !mergeJunction) {
                    log(`WARNING: Missing junctions for branch ${branchIndex}`);
                    return;
                }
                
                const mainLineY = layout.inputs.y;
                
                try {
                    // STEP 1: Draw T-junction SPLIT (validated)
                    ctx.strokeStyle = '#6b7280';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    
                    // Vertical line down from main line at split junction
                    ctx.beginPath();
                    ctx.moveTo(splitJunction.x, mainLineY);
                    
                    // Calculate proper vertical extent based on paths
                    const maxPathY = Math.max(...branch.paths.map(p => p.y));
                    const minPathY = Math.min(...branch.paths.map(p => p.y));
                    const verticalExtent = Math.max(maxPathY, mainLineY + 40);
                    
                    ctx.lineTo(splitJunction.x, verticalExtent);
                    ctx.stroke();
                    
                    // STEP 2: Draw each parallel path with MINIMAL horizontal lines
                    branch.paths.forEach((path, pathIndex) => {
                        if (!path.elements || path.elements.length === 0) {
                            log(`WARNING: Path ${pathIndex} in branch ${branchIndex} has no elements`);
                            return;
                        }
                        
                        // Draw main horizontal line for this path
                        ctx.beginPath();
                        ctx.moveTo(splitJunction.x, path.y);
                        ctx.lineTo(mergeJunction.x, path.y);
                        ctx.stroke();
                        
                        // CRITICAL FIX: Minimal horizontal line to first element
                        const firstElement = path.elements[0];
                        if (firstElement) {
                            // Very short horizontal line from split to element (5px max)
                            ctx.beginPath();
                            ctx.moveTo(splitJunction.x, path.y);
                            ctx.lineTo(splitJunction.x + 5, path.y); // Only 5px horizontal
                            ctx.stroke();
                            
                            // Connect to first element if it's further than 5px
                            if (firstElement.x - firstElement.width/2 > splitJunction.x + 5) {
                                ctx.beginPath();
                                ctx.moveTo(splitJunction.x + 5, path.y);
                                ctx.lineTo(firstElement.x - firstElement.width/2, path.y);
                                ctx.stroke();
                            }
                        }
                        
                        // Draw connections between elements within path
                        for (let i = 0; i < path.elements.length - 1; i++) {
                            const current = path.elements[i];
                            const next = path.elements[i + 1];
                            
                            if (current && next) {
                                ctx.beginPath();
                                ctx.moveTo(current.x + current.width/2, path.y);
                                ctx.lineTo(next.x - next.width/2, path.y);
                                ctx.stroke();
                            }
                        }
                        
                        // Connect last element to merge
                        const lastElement = path.elements[path.elements.length - 1];
                        if (lastElement) {
                            ctx.beginPath();
                            ctx.moveTo(lastElement.x + lastElement.width/2, path.y);
                            ctx.lineTo(mergeJunction.x, path.y);
                            ctx.stroke();
                        }
                    });
                    
                    // STEP 3: Draw T-junction MERGE (validated)
                    ctx.beginPath();
                    ctx.moveTo(mergeJunction.x, minPathY);
                    ctx.lineTo(mergeJunction.x, mainLineY);
                    ctx.stroke();
                    
                } catch (error) {
                    log('ERROR in branch drawing: ' + error.message);
                }
            });
        }

        function drawPowerRailConnections(ctx, layout) {
            if (layout.inputs.elements.length > 0) {
                const firstElement = layout.inputs.elements[0];
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(layout.powerRailLeft, Math.round(firstElement.y));
                ctx.lineTo(Math.round(firstElement.x - firstElement.width / 2), Math.round(firstElement.y));
                ctx.stroke();
            }
            
            if (layout.outputs.elements.length > 0) {
                const lastElement = layout.outputs.elements[layout.outputs.elements.length - 1];
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(Math.round(lastElement.x + lastElement.width / 2), Math.round(lastElement.y));
                ctx.lineTo(layout.powerRailRight, Math.round(lastElement.y));
                ctx.stroke();
            }
        }

        function drawContact(ctx, x, y, instruction, tag, element) {
            // Validate inputs
            if (!ctx || typeof x !== 'number' || typeof y !== 'number' || !instruction) {
                log('ERROR: Invalid parameters passed to drawContact');
                return;
            }
            
            const width = 35;
            const height = 25;
            
            // Draw contact rectangle with validation
            ctx.save(); // Save context state
            
            try {
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 2;
                ctx.fillStyle = '#ffffff';
                
                const rectX = Math.round(x - width/2);
                const rectY = Math.round(y - height/2);
                
                ctx.strokeRect(rectX, rectY, width, height);
                ctx.fillRect(rectX, rectY, width, height);
                ctx.strokeRect(rectX, rectY, width, height);

                // Draw contact symbol with validation
                const symbol = instruction === 'XIC' ? '| |' : instruction === 'XIO' ? '|/|' : '|?|';
                ctx.font = 'bold 12px "Courier New", monospace';
                ctx.fillStyle = '#1f2937';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, x, y);

                // CRITICAL FIX: Enhanced tag positioning for all cases
                if (tag && tag.trim()) {
                    ctx.font = '10px "Courier New", monospace';
                    ctx.fillStyle = '#6b7280';
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';
                    
                    let tagX, tagY;
                    
                    // Handle parallel branch tags (hug the split)
                    if (element && element.branchType === 'parallel' && typeof element.splitX === 'number') {
                        tagX = element.splitX + 2; // Just 2px right of split line
                        tagY = Math.round(y - height/2 - 12); // Above the contact
                        
                        // Validate tag position doesn't go off canvas
                        if (tagX < 0) tagX = 5;
                        if (tagY < 10) tagY = Math.round(y + height/2 + 5); // Move below if no room above
                        
                    } else {
                        // Handle main branch tags (standard positioning)
                        tagX = Math.round(x - width/2 - 5);
                        tagY = Math.round(y + height/2 + 5);
                        
                        // Validate main branch tag position
                        if (tagX < 25) tagX = 25; // Don't overlap power rail
                    }
                    
                    // Additional validation for tag length
                    const displayTag = tag.length > 15 ? tag.substring(0, 12) + '...' : tag;
                    ctx.fillText(displayTag, tagX, tagY);
                    
                    log(`Tag "${displayTag}" positioned at (${tagX}, ${tagY}) for ${element?.branchType || 'main'} branch`);
                }
                
            } catch (error) {
                log('ERROR in drawContact: ' + error.message);
            } finally {
                ctx.restore(); // Restore context state
            }
        }

        function drawCoil(ctx, x, y, instruction, tag) {
            const radius = 18;
            
            ctx.strokeStyle = '#ea580c';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            let symbol = '( )';
            if (instruction === 'OTL') symbol = '(L)';
            else if (instruction === 'OTU') symbol = '(U)';
            
            ctx.font = 'bold 12px "Courier New", monospace';
            ctx.fillStyle = '#1f2937';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(symbol, x, y);

            if (tag) {
                ctx.font = '10px "Courier New", monospace';
                ctx.fillStyle = '#6b7280';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                const tagY = Math.round(y + radius + 15);
                ctx.fillText(tag, x, tagY);
            }
        }

        function drawFunctionBlock(ctx, x, y, instruction, tag) {
            const width = 60;
            const height = 30;
            
            ctx.strokeStyle = '#7c3aed';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#ffffff';
            
            const rectX = Math.round(x - width/2);
            const rectY = Math.round(y - height/2);
            ctx.strokeRect(rectX, rectY, width, height);
            ctx.fillRect(rectX, rectY, width, height);
            ctx.strokeRect(rectX, rectY, width, height);

            ctx.font = 'bold 12px "Courier New", monospace';
            ctx.fillStyle = '#1f2937';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(instruction, x, y);

            if (tag) {
                ctx.font = '10px "Courier New", monospace';
                ctx.fillStyle = '#6b7280';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                const tagY = Math.round(y + height/2 + 15);
                ctx.fillText(tag, x, tagY);
            }
        }

        function getElementType(instruction) {
            if (['XIC', 'XIO'].includes(instruction)) return 'contact';
            if (['OTE', 'OTL', 'OTU'].includes(instruction)) return 'coil';
            return 'function';
        }

        function getElementWidth(instruction) {
            if (['XIC', 'XIO'].includes(instruction)) return 35;
            if (['OTE', 'OTL', 'OTU'].includes(instruction)) return 36;
            return 60;
        }

        function calculateElementWidth(instruction, tag) {
            // Validate inputs
            if (!instruction) return 50; // Default width
            if (!tag) tag = '';
            
            const baseWidth = getElementWidth(instruction);
            const tagWidth = tag.length * 7; // 7px per character
            
            // Ensure minimum width but don't make it too wide
            const minWidth = baseWidth + 10;
            const maxWidth = baseWidth + 60; // Cap maximum width
            
            return Math.min(Math.max(minWidth, tagWidth + 15), maxWidth);
        }

        function getElementHeight(instruction) {
            if (['XIC', 'XIO'].includes(instruction)) return 25;
            if (['OTE', 'OTL', 'OTU'].includes(instruction)) return 36;
            return 30;
        }

        // Auto-run test on load
        window.onload = function() {
            console.log('Parallel Branch Layout Test Ready');
            console.log('âœ… All improvements applied and verified');
        };
    </script>
</body>
</html> 