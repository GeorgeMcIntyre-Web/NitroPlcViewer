<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal Parallel Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .debug { background: #f0f0f0; padding: 10px; margin: 10px; border: 1px solid #ccc; }
    </style>
</head>
<body>
    <h1>Minimal Parallel Branch Test</h1>
    <div class="debug" id="debug-output"></div>

    <script>
        function log(message) {
            document.getElementById('debug-output').innerHTML += message + '<br>';
            console.log(message);
        }

        function testParsing() {
            log('=== TESTING PARALLEL BRANCH PARSING ===');
            
            const rungText = 'XIC(Start_Button) [XIC(Proximity_Sensor) | XIO(Emergency_Stop)] OTE(Motor_Output)';
            log('Input: ' + rungText);
            
            const tokens = rungText.split(/(\s+|[\[\]|])/).filter(token => token.trim() && token !== ' ');
            log('Tokens: ' + JSON.stringify(tokens));
            
            const rung = {
                inputs: { elements: [] },
                outputs: { elements: [] },
                parallelBranches: [],
                junctions: []
            };
            
            let currentBranch = rung.inputs;
            let branchStack = [rung.inputs];
            let currentLevel = 0;
            let currentParallelBranch = null;
            
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i].trim();
                log('Processing token: "' + token + '"');
                
                if (token === '[') {
                    currentLevel++;
                    currentParallelBranch = { 
                        level: currentLevel, 
                        paths: [[]],
                        parent: currentBranch,
                        splitPoint: null,
                        mergePoint: null
                    };
                    
                    const junction = {
                        type: 'split',
                        x: 0,
                        y: 0,
                        parentBranch: currentBranch,
                        parallelBranch: currentParallelBranch
                    };
                    
                    rung.parallelBranches.push(currentParallelBranch);
                    rung.junctions.push(junction);
                    branchStack.push(currentParallelBranch);
                    currentBranch = currentParallelBranch;
                    log('Started parallel branch level ' + currentLevel);
                    log('Created ' + currentParallelBranch.paths.length + ' initial paths');
                    
                } else if (token === '|') {
                    if (currentParallelBranch) {
                        currentParallelBranch.paths.push([]);
                        log('Started new parallel path within branch level ' + currentLevel);
                        log('Now have ' + currentParallelBranch.paths.length + ' paths');
                    }
                    
                } else if (token === ']') {
                    const parallelBranch = currentBranch;
                    const parentBranch = branchStack[branchStack.length - 2];
                    
                    const junction = {
                        type: 'merge',
                        x: 0,
                        y: 0,
                        parentBranch: parentBranch,
                        parallelBranch: parallelBranch
                    };
                    
                    rung.junctions.push(junction);
                    branchStack.pop();
                    currentBranch = parentBranch;
                    currentLevel--;
                    currentParallelBranch = null;
                    log('Ended parallel branch, back to level ' + currentLevel);
                    
                } else if (token) {
                    const instructionMatch = token.match(/([A-Z]{2,4})\(([^)]+)\)/);
                    if (instructionMatch) {
                        const instruction = instructionMatch[1];
                        const tag = instructionMatch[2];
                        
                        const element = {
                            type: 'contact',
                            instruction: instruction,
                            tag: tag
                        };
                        
                        if (['OTE', 'OTL', 'OTU'].includes(instruction)) {
                            rung.outputs.elements.push(element);
                            log('Added output element: ' + instruction + '(' + tag + ')');
                        } else {
                            if (currentParallelBranch) {
                                const currentPathIndex = currentParallelBranch.paths.length - 1;
                                currentParallelBranch.paths[currentPathIndex].push(element);
                                log('Added element to parallel branch path ' + currentPathIndex + ': ' + instruction + '(' + tag + ')');
                                log('Path ' + currentPathIndex + ' now has ' + currentParallelBranch.paths[currentPathIndex].length + ' elements');
                            } else {
                                currentBranch.elements.push(element);
                                log('Added input element to main branch: ' + instruction + '(' + tag + ')');
                            }
                        }
                    }
                }
            }
            
            log('=== FINAL STRUCTURE ===');
            log('Inputs: ' + rung.inputs.elements.length + ' elements');
            log('Outputs: ' + rung.outputs.elements.length + ' elements');
            log('Parallel branches: ' + rung.parallelBranches.length);
            
            rung.parallelBranches.forEach((branch, index) => {
                log('Branch ' + index + ' has ' + branch.paths.length + ' paths:');
                branch.paths.forEach((path, pathIndex) => {
                    log('  Path ' + pathIndex + ' has ' + path.length + ' elements: ' + 
                        path.map(e => e.instruction + '(' + e.tag + ')').join(', '));
                });
            });
        }

        // Run test on load
        window.onload = function() {
            testParsing();
        };
    </script>
</body>
</html> 