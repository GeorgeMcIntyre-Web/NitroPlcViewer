<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ladder Logic Canvas Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        canvas {
            border: 2px solid #ccc;
            margin: 10px 0;
        }
        button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #1d4ed8;
        }
        .debug-info {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>Ladder Logic Canvas Test</h1>
    
    <div class="test-container">
        <h2>Basic Canvas Test</h2>
        <button onclick="testBasicCanvas()">Test Basic Canvas</button>
        <div id="basic-test"></div>
    </div>
    
    <div class="test-container">
        <h2>Ladder Symbol Test</h2>
        <button onclick="testLadderSymbols()">Test Ladder Symbols</button>
        <div id="ladder-test"></div>
    </div>
    
    <div class="test-container">
        <h2>Simple Rung Test</h2>
        <button onclick="testSimpleRung()">Test Simple Rung</button>
        <div id="simple-rung-test"></div>
    </div>
    
    <div class="test-container">
        <h2>Parallel Branch Test</h2>
        <button onclick="testParallelBranch()">Test Parallel Branch</button>
        <div id="parallel-branch-test"></div>
    </div>
    
    <div class="test-container">
        <h2>Complex Nested Test</h2>
        <button onclick="testComplexNested()">Test Complex Nested</button>
        <div id="complex-nested-test"></div>
    </div>
    
    <div class="debug-info" id="debug-output">
        Debug output will appear here...
    </div>

    <script>
        function log(message) {
            const debug = document.getElementById('debug-output');
            debug.innerHTML += message + '<br>';
            console.log(message);
        }

        function clearDebug() {
            document.getElementById('debug-output').innerHTML = 'Debug output will appear here...<br>';
        }

        function testBasicCanvas() {
            clearDebug();
            log('=== BASIC CANVAS TEST ===');
            
            const container = document.getElementById('basic-test');
            container.innerHTML = '';
            
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 100;
            canvas.style.border = '2px solid red';
            
            const ctx = canvas.getContext('2d');
            log('Canvas created: ' + canvas.width + 'x' + canvas.height);
            
            // Test basic drawing
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(10, 10, 50, 30);
            log('Red rectangle drawn at (10,10)');
            
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(70, 10, 50, 30);
            log('Green rectangle drawn at (70,10)');
            
            ctx.fillStyle = '#0000ff';
            ctx.fillRect(130, 10, 50, 30);
            log('Blue rectangle drawn at (130,10)');
            
            ctx.fillStyle = '#000000';
            ctx.font = '16px Arial';
            ctx.fillText('CANVAS TEST', 10, 70);
            log('Text drawn: CANVAS TEST');
            
            container.appendChild(canvas);
            log('Canvas added to page');
            log('=== BASIC CANVAS TEST COMPLETE ===');
        }

        function testLadderSymbols() {
            clearDebug();
            log('=== LADDER SYMBOL TEST ===');
            
            const container = document.getElementById('ladder-test');
            container.innerHTML = '';
            
            const canvas = document.createElement('canvas');
            canvas.width = 800;
            canvas.height = 200;
            canvas.style.border = '2px solid blue';
            
            const ctx = canvas.getContext('2d');
            log('Canvas created: ' + canvas.width + 'x' + canvas.height);
            
            // Clear with white background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            log('Canvas cleared with white background');
            
            // Draw left and right power rails (thick green lines)
            ctx.strokeStyle = '#10b981'; // Green color for power rails
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(20, 20);
            ctx.lineTo(20, canvas.height - 20);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(canvas.width - 20, 20);
            ctx.lineTo(canvas.width - 20, canvas.height - 20);
            ctx.stroke();
            log('Power rails drawn');
            
            // Draw main horizontal connection line (grey like Studio 5000)
            ctx.strokeStyle = '#6b7280'; // Grey color for main connection line
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(40, 100);
            ctx.lineTo(canvas.width - 40, 100);
            ctx.stroke();
            log('Main connection line drawn');
            
            // Position inputs on the left side
            let currentX = 80;
            const mainLineY = 100;
            
            // XIC contact
            drawContact(ctx, currentX, mainLineY, 'XIC', 'Start_Button');
            log('XIC contact drawn at (' + currentX + ',' + mainLineY + ')');
            currentX += 80;
            
            // XIO contact
            drawContact(ctx, currentX, mainLineY, 'XIO', 'Stop_Button');
            log('XIO contact drawn at (' + currentX + ',' + mainLineY + ')');
            currentX += 80;
            
            // TON function block
            drawFunctionBlock(ctx, currentX, mainLineY, 'TON', 'Timer1');
            log('TON function block drawn at (' + currentX + ',' + mainLineY + ')');
            currentX += 100;
            
            // TOF function block
            drawFunctionBlock(ctx, currentX, mainLineY, 'TOF', 'Timer2');
            log('TOF function block drawn at (' + currentX + ',' + mainLineY + ')');
            currentX += 100;
            
            // CTU function block
            drawFunctionBlock(ctx, currentX, mainLineY, 'CTU', 'Counter1');
            log('CTU function block drawn at (' + currentX + ',' + mainLineY + ')');
            currentX += 100;
            
            // Position outputs on the right side
            const outputStartX = canvas.width - 300;
            currentX = outputStartX;
            
            // OTE coil
            drawCoil(ctx, currentX, mainLineY, 'OTE', 'Run_Light');
            log('OTE coil drawn at (' + currentX + ',' + mainLineY + ')');
            currentX += 80;
            
            // OTL coil
            drawCoil(ctx, currentX, mainLineY, 'OTL', 'Latch_Output');
            log('OTL coil drawn at (' + currentX + ',' + mainLineY + ')');
            currentX += 80;
            
            // OTU coil
            drawCoil(ctx, currentX, mainLineY, 'OTU', 'Unlatch_Output');
            log('OTU coil drawn at (' + currentX + ',' + mainLineY + ')');
            
            container.appendChild(canvas);
            log('Canvas added to page');
            log('=== LADDER SYMBOL TEST COMPLETE ===');
        }

        function testSimpleRung() {
            clearDebug();
            log('=== SIMPLE RUNG TEST ===');
            
            const testRung = {
                text: 'XIC(Start_Button) XIO(Stop_Button) OTE(Motor_Output)'
            };
            
            renderRung(testRung, 'simple-rung-test', 800, 120);
            log('=== SIMPLE RUNG TEST COMPLETE ===');
        }

        function testParallelBranch() {
            clearDebug();
            log('=== PARALLEL BRANCH TEST ===');
            
            const testRung = {
                text: 'XIC(Start_Button) [XIC(Proximity_Sensor) | XIO(Emergency_Stop)] OTE(Motor_Output)'
            };
            
            renderRung(testRung, 'parallel-branch-test', 800, 350);
            log('=== PARALLEL BRANCH TEST COMPLETE ===');
        }

        function testComplexNested() {
            clearDebug();
            log('=== COMPLEX NESTED TEST ===');
            
            const testRung = {
                text: 'XIC(Start_Button) XIO(Emergency_Stop) [TON(Delay_Timer)] OTE(Latch_Output) OTE(Motor_Output)'
            };
            
            renderRung(testRung, 'complex-nested-test', 900, 400);
            log('=== COMPLEX NESTED TEST COMPLETE ===');
        }

        function renderRung(rung, containerId, width, height) {
            log('Rendering rung: ' + rung.text);
            
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            canvas.style.border = '2px solid green';
            
            const ctx = canvas.getContext('2d');
            log('Canvas created: ' + canvas.width + 'x' + canvas.height);
            
            // Clear with white background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            log('Canvas cleared with white background');
            
            // Parse the rung with branch detection
            const parsedRung = parseRungLogic(rung.text);
            log('Parsed rung structure: ' + JSON.stringify(parsedRung, null, 2));
            
            // Calculate layout
            const layout = calculateLayout(parsedRung, width, height);
            log('Layout calculated: ' + JSON.stringify(layout, null, 2));
            
            // Draw power rails
            drawPowerRails(ctx, width, height);
            
            // Draw all branches and elements
            drawBranches(ctx, parsedRung, layout);
            
            container.appendChild(canvas);
            log('Canvas added to page');
        }

        function parseRungLogic(rungText) {
            log('Parsing rung text: ' + rungText);
            
            const tokens = rungText.split(/(\s+|[\[\]|])/).filter(token => token.trim() && token !== ' ');
            log('Tokens: ' + JSON.stringify(tokens));
            
            // Create main rung structure with separate input and output sections
            const rung = {
                inputs: { elements: [] },
                outputs: { elements: [] },
                parallelBranches: [],
                junctions: []
            };
            
            let currentBranch = rung.inputs;
            let branchStack = [rung.inputs];
            let currentLevel = 0;
            let currentParallelBranch = null;
            
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i].trim();
                
                if (token === '[') {
                    // Start parallel branch - create junction point
                    currentLevel++;
                    currentParallelBranch = { 
                        level: currentLevel, 
                        paths: [[]], // Array of paths, each path is an array of elements
                        parent: currentBranch,
                        splitPoint: null,
                        mergePoint: null
                    };
                    
                    // Add junction for branch split
                    const junction = {
                        type: 'split',
                        x: 0, // Will be calculated during layout
                        y: 0,
                        parentBranch: currentBranch,
                        parallelBranch: currentParallelBranch
                    };
                    
                    rung.parallelBranches.push(currentParallelBranch);
                    rung.junctions.push(junction);
                    branchStack.push(currentParallelBranch);
                    currentBranch = currentParallelBranch;
                    log('Started parallel branch level ' + currentLevel);
                    
                } else if (token === '|') {
                    // Start new parallel path within current branch
                    if (currentParallelBranch) {
                        currentParallelBranch.paths.push([]);
                        log('Started new parallel path within branch level ' + currentLevel);
                        log('Now have ' + currentParallelBranch.paths.length + ' paths');
                    }
                    
                } else if (token === ']') {
                    // End parallel branch - create merge junction
                    const parallelBranch = currentBranch;
                    const parentBranch = branchStack[branchStack.length - 2];
                    
                    // Add junction for branch merge
                    const junction = {
                        type: 'merge',
                        x: 0, // Will be calculated during layout
                        y: 0,
                        parentBranch: parentBranch,
                        parallelBranch: parallelBranch
                    };
                    
                    rung.junctions.push(junction);
                    branchStack.pop();
                    currentBranch = parentBranch;
                    currentLevel--;
                    currentParallelBranch = null;
                    log('Ended parallel branch, back to level ' + currentLevel);
                    
                } else if (token) {
                    // Parse instruction and add to current branch
                    const instructionMatch = token.match(/([A-Z]{2,4})\(([^)]+)\)/);
                    if (instructionMatch) {
                        const instruction = instructionMatch[1];
                        const tag = instructionMatch[2];
                        
                        const element = {
                            type: getElementType(instruction),
                            instruction: instruction,
                            tag: tag,
                            width: calculateElementWidth(instruction, tag),
                            height: getElementHeight(instruction)
                        };
                        
                        // Determine if this should go to inputs or outputs based on instruction type
                        if (['OTE', 'OTL', 'OTU'].includes(instruction)) {
                            // Outputs go to the right side
                            rung.outputs.elements.push(element);
                            log('Added output element: ' + instruction + '(' + tag + ')');
                        } else {
                            // Inputs and function blocks go to the left side
                            if (currentParallelBranch) {
                                // Add to current parallel branch path
                                const currentPathIndex = currentParallelBranch.paths.length - 1;
                                currentParallelBranch.paths[currentPathIndex].push(element);
                                log('Added element to parallel branch path ' + currentPathIndex + ': ' + instruction + '(' + tag + ')');
                                log('Current paths count: ' + currentParallelBranch.paths.length);
                                log('Current path ' + currentPathIndex + ' has ' + currentParallelBranch.paths[currentPathIndex].length + ' elements');
                            } else {
                                // Add to main input branch
                                currentBranch.elements.push(element);
                                log('Added input/function element to level ' + currentLevel + ': ' + instruction + '(' + tag + ')');
                            }
                        }
                    }
                }
            }
            
            log('Final rung structure: ' + JSON.stringify(rung, null, 2));
            
            // Log detailed parallel branch information
            rung.parallelBranches.forEach((branch, index) => {
                log('Branch ' + index + ' has ' + branch.paths.length + ' paths:');
                branch.paths.forEach((path, pathIndex) => {
                    log('  Path ' + pathIndex + ' has ' + path.length + ' elements: ' + 
                        path.map(e => e.instruction + '(' + e.tag + ')').join(', '));
                });
            });
            
            return rung;
        }

        function calculateLayout(rungStructure, canvasWidth, canvasHeight) {
            const layout = {
                inputs: { elements: [], y: 100 },
                outputs: { elements: [], y: 100 },
                parallelBranches: [],
                junctions: [],
                powerRailLeft: 20,
                powerRailRight: canvasWidth - 20
            };
            
            // INCREASE START SPACING - More padding from left power rail
            let currentX = 200; // Dramatically increased from 120px to 200px for much longer start line
            const elementSpacing = 40;
            const mainLineY = 100;
            
            // Position input elements with proper spacing
            rungStructure.inputs.elements.forEach(element => {
                element.x = Math.round(currentX);
                element.y = Math.round(mainLineY);
                element.branchType = 'input';
                layout.inputs.elements.push(element);
                currentX += element.width + elementSpacing;
            });
            
            // POSITION BRANCH SPLITS FURTHER LEFT - After inputs, before outputs
            const splitX = layout.inputs.elements.length > 0 ? 
                layout.inputs.elements[layout.inputs.elements.length - 1].x + 80 : // Further reduced from 120px to 80px for much tighter spacing
                280; // Increased default position to match new start spacing

            // POSITION OUTPUTS AT FAR RIGHT - Extend to right power rail
            if (rungStructure.outputs.elements.length > 0) {
                // Calculate total width needed for all outputs
                const totalOutputWidth = rungStructure.outputs.elements.reduce((sum, element) => sum + element.width, 0);
                const totalSpacing = (rungStructure.outputs.elements.length - 1) * elementSpacing;
                const totalRequiredWidth = totalOutputWidth + totalSpacing + 40; // 40px padding from right rail
                
                // Calculate merge junction position to ensure proper spacing
                const mergeJunctionX = splitX + 200 + 40; // Same as merge junction calculation
                
                // Ensure outputs start after merge junction with proper spacing
                const minOutputStartX = mergeJunctionX + 40; // Further reduced from 80px to 40px for much tighter spacing
                const rightAlignedOutputX = canvasWidth - 20 - totalRequiredWidth;
                
                // Use the later of the two positions to ensure proper spacing
                let currentOutputX = Math.max(minOutputStartX, rightAlignedOutputX);
                
                rungStructure.outputs.elements.forEach(element => {
                    element.x = Math.round(currentOutputX);
                    element.y = Math.round(mainLineY);
                    element.branchType = 'output';
                    layout.outputs.elements.push(element);
                    currentOutputX += element.width + elementSpacing;
                });
            }
            
            // Calculate parallel branch positions with proper split positioning
            rungStructure.parallelBranches.forEach((parallelBranch, index) => {
                const branchLayout = {
                    paths: [],
                    level: parallelBranch.level,
                    splitX: splitX // Common split position for all parallel branches
                };
                
                // Calculate spacing for multiple paths
                const pathSpacing = 60; // Increased spacing between parallel paths for better visual separation
                const totalPaths = parallelBranch.paths.length;
                const totalHeight = (totalPaths - 1) * pathSpacing;
                const startY = mainLineY + 80; // Base Y position for first path
                
                // Position each path
                parallelBranch.paths.forEach((path, pathIndex) => {
                    const pathLayout = {
                        elements: [],
                        y: startY + pathIndex * pathSpacing // Each path gets its own Y position
                    };
                    
                    // Position elements horizontally within this path
                    let pathX = splitX + 20; // Move contact much closer to split
                    
                    path.forEach(element => {
                        element.x = Math.round(pathX);
                        element.y = Math.round(pathLayout.y);
                        element.branchType = 'parallel';
                        element.branchLevel = parallelBranch.level;
                        element.pathIndex = pathIndex;
                        element.splitX = splitX; // Pass splitX for tag positioning
                        pathLayout.elements.push(element);
                        pathX += element.width + elementSpacing;
                    });
                    
                    // Log path information for debugging
                    if (path.length > 0) {
                        log(`Path ${pathIndex} positioned at Y=${pathLayout.y} with ${path.length} elements`);
                        path.forEach((element, elementIndex) => {
                            log(`  Element ${elementIndex}: ${element.instruction}(${element.tag}) at (${element.x}, ${element.y})`);
                        });
                    }
                    
                    branchLayout.paths.push(pathLayout);
                });
                
                layout.parallelBranches.push(branchLayout);
            });
            
            // Position junctions at proper split/merge points
            let splitJunctions = rungStructure.junctions.filter(j => j.type === 'split');
            let mergeJunctions = rungStructure.junctions.filter(j => j.type === 'merge');
            
            // Split junctions at common position (further left)
            splitJunctions.forEach((junction, index) => {
                junction.x = Math.round(splitX);
                junction.y = Math.round(mainLineY);
                layout.junctions.push(junction);
            });
            
            // Merge junctions will be positioned after parallel branch elements are positioned
            mergeJunctions.forEach((junction, index) => {
                junction.y = Math.round(mainLineY);
                layout.junctions.push(junction);
            });
            
            // Position merge junctions based on fixed branch area
            layout.parallelBranches.forEach((branch, branchIndex) => {
                const mergeJunction = mergeJunctions[branchIndex];
                if (mergeJunction) {
                    // Position merge junction at the end of the fixed branch area with much shorter spacing
                    mergeJunction.x = Math.round(splitX + 200 + 40); // 200px branch width + 40px spacing for much shorter end line
                }
            });
            
            // Connect parallel branches to T-junctions
            layout.parallelBranches.forEach((branch, branchIndex) => {
                if (branch.paths.length > 0) {
                    // Find corresponding split and merge junctions
                    const splitJunction = splitJunctions[branchIndex];
                    const mergeJunction = mergeJunctions[branchIndex];
                    
                    if (splitJunction) {
                        // Link junction to parallel branch
                        splitJunction.parallelBranch = rungStructure.parallelBranches[branchIndex];
                        // Connect split junction to first parallel path
                        const firstPath = branch.paths[0];
                        if (firstPath && firstPath.elements.length > 0) {
                            const firstElement = firstPath.elements[0];
                            splitJunction.parallelStartX = firstElement.x - firstElement.width / 2;
                            splitJunction.parallelStartY = firstPath.y;
                        }
                    }
                    
                    if (mergeJunction) {
                        // Link junction to parallel branch
                        mergeJunction.parallelBranch = rungStructure.parallelBranches[branchIndex];
                        // Connect last parallel path to merge junction
                        const lastPath = branch.paths[branch.paths.length - 1];
                        if (lastPath && lastPath.elements.length > 0) {
                            const lastElement = lastPath.elements[lastPath.elements.length - 1];
                            mergeJunction.parallelEndX = lastElement.x + lastElement.width / 2;
                            mergeJunction.parallelEndY = lastPath.y;
                        }
                    }
                }
            });
            
            return layout;
        }



        function drawPowerRails(ctx, width, height) {
            // Draw left and right power rails (thick green lines)
            ctx.strokeStyle = '#10b981'; // Green color for power rails
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(20, 20);
            ctx.lineTo(20, height - 20);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(width - 20, 20);
            ctx.lineTo(width - 20, height - 20);
            ctx.stroke();
            log('Power rails drawn');
        }

        function drawBranches(ctx, rungStructure, layout) {
            // Draw power rail connections first
            drawPowerRailConnections(ctx, layout);
            
            // Draw main horizontal line from left to right power rail
            ctx.strokeStyle = '#6b7280';
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(layout.powerRailLeft, layout.inputs.y);
            ctx.lineTo(layout.powerRailRight, layout.inputs.y);
            ctx.stroke();
            log('Main horizontal line drawn from left to right power rail');
            
            // Draw all elements first (so they appear behind connection lines)
            const allElements = [
                ...layout.inputs.elements,
                ...layout.outputs.elements,
                ...layout.parallelBranches.flatMap(branch => branch.paths.flatMap(path => path.elements))
            ];
            
            allElements.forEach(element => {
                if (element.type === 'contact') {
                    drawContact(ctx, element.x, element.y, element.instruction, element.tag, element);
                } else if (element.type === 'coil') {
                    drawCoil(ctx, element.x, element.y, element.instruction, element.tag);
                } else if (element.type === 'function') {
                    drawFunctionBlock(ctx, element.x, element.y, element.instruction, element.tag);
                }
            });
            
            // Draw connections between elements within input and output sections
            [layout.inputs, layout.outputs].forEach(branch => {
                for (let i = 0; i < branch.elements.length - 1; i++) {
                    const current = branch.elements[i];
                    const next = branch.elements[i + 1];
                    
                    ctx.strokeStyle = '#6b7280';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    
                    const startX = Math.round(current.x + current.width / 2);
                    const endX = Math.round(next.x - next.width / 2);
                    const y = Math.round(branch.y);
                    
                    // Clean horizontal connection
                    ctx.beginPath();
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                    ctx.stroke();
                    log('Element connection drawn from (' + startX + ',' + y + ') to (' + endX + ',' + y + ')');
                }
            });
            
            // Draw parallel branch connections with proper T-junctions
            layout.parallelBranches.forEach((branch, branchIndex) => {
                if (branch.paths.length > 0) {
                    // Find corresponding junctions
                    const splitJunction = layout.junctions.find(j => j.type === 'split' && j.parallelBranch && j.parallelBranch.level === branch.level);
                    const mergeJunction = layout.junctions.find(j => j.type === 'merge' && j.parallelBranch && j.parallelBranch.level === branch.level);
                    
                    if (splitJunction && mergeJunction) {
                        const mainLineY = layout.inputs.y;
                        
                        // STEP 1: Draw T-junction SPLIT
                        ctx.strokeStyle = '#6b7280';
                        ctx.lineWidth = 3;
                        
                        // ONE vertical line down from main line at split junction
                        ctx.beginPath();
                        ctx.moveTo(splitJunction.x, mainLineY);
                        ctx.lineTo(splitJunction.x, mainLineY + 40); // Further reduced from 60px to 40px for much more compact layout
                        ctx.stroke();
                        log('Split vertical line drawn from main line');
                        
                        // STEP 2: Draw each parallel path with clean connections
                        branch.paths.forEach((path, pathIndex) => {
                            // Draw horizontal line for this parallel path
                            ctx.strokeStyle = '#6b7280';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(splitJunction.x, path.y);
                            ctx.lineTo(mergeJunction.x, path.y);
                            ctx.stroke();
                            log('Horizontal line for parallel path ' + pathIndex);
                            
                            // Draw horizontal connections between elements within this path
                            for (let i = 0; i < path.elements.length - 1; i++) {
                                const current = path.elements[i];
                                const next = path.elements[i + 1];
                                
                                ctx.strokeStyle = '#6b7280';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(current.x + current.width / 2, path.y);
                                ctx.lineTo(next.x - next.width / 2, path.y);
                                ctx.stroke();
                                log('Horizontal connection within path ' + pathIndex);
                            }
                            
                            // Draw vertical drop from split line to this path's Y level
                            if (path.elements.length > 0) {
                                const firstElement = path.elements[0];
                                
                                // Vertical line from split vertical to path level
                                ctx.strokeStyle = '#6b7280';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(splitJunction.x, mainLineY + 40);
                                ctx.lineTo(splitJunction.x, path.y);
                                ctx.stroke();
                                
                                // Horizontal line from vertical drop to first element
                                ctx.beginPath();
                                ctx.moveTo(splitJunction.x, path.y);
                                ctx.lineTo(firstElement.x - firstElement.width / 2, path.y);
                                ctx.stroke();
                                log('Split connection to path ' + pathIndex);
                            }
                            
                            // Draw connection from last element to merge collection
                            if (path.elements.length > 0) {
                                const lastElement = path.elements[path.elements.length - 1];
                                
                                // Horizontal line from last element to merge vertical
                                ctx.strokeStyle = '#6b7280';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(lastElement.x + lastElement.width / 2, path.y);
                                ctx.lineTo(mergeJunction.x, path.y);
                                ctx.stroke();
                                
                                // Vertical line from path level to merge collection level
                                ctx.beginPath();
                                ctx.moveTo(mergeJunction.x, path.y);
                                ctx.lineTo(mergeJunction.x, mainLineY + 40);
                                ctx.stroke();
                                log('Merge connection from path ' + pathIndex);
                            }
                        });
                        
                        // STEP 3: Draw T-junction MERGE
                        // ONE vertical line up from merge collection level to main line
                        ctx.strokeStyle = '#6b7280';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(mergeJunction.x, mainLineY + 40);
                        ctx.lineTo(mergeJunction.x, mainLineY);
                        ctx.stroke();
                        log('Merge vertical line drawn to main line');
                    }
                }
            });
        }

        function drawPowerRailConnections(ctx, layout) {
            // Connect left power rail to first input with proper spacing
            if (layout.inputs.elements.length > 0) {
                const firstElement = layout.inputs.elements[0];
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(layout.powerRailLeft, Math.round(firstElement.y));
                ctx.lineTo(Math.round(firstElement.x - firstElement.width / 2), Math.round(firstElement.y));
                ctx.stroke();
                log('Left power rail connection drawn to first input element at (' + firstElement.x + ',' + firstElement.y + ')');
            }
            
            // Connect last output to right power rail (far right)
            if (layout.outputs.elements.length > 0) {
                const lastElement = layout.outputs.elements[layout.outputs.elements.length - 1];
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(Math.round(lastElement.x + lastElement.width / 2), Math.round(lastElement.y));
                ctx.lineTo(layout.powerRailRight, Math.round(lastElement.y));
                ctx.stroke();
                log('Right power rail connection drawn from last output element at (' + lastElement.x + ',' + lastElement.y + ')');
            }
        }

        function drawContact(ctx, x, y, instruction, tag, element) {
            const width = 35;
            const height = 25;
            
            // Draw contact rectangle
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#ffffff';
            
            const rectX = Math.round(x - width/2);
            const rectY = Math.round(y - height/2);
            
            ctx.strokeRect(rectX, rectY, width, height);
            ctx.fillRect(rectX, rectY, width, height);
            ctx.strokeRect(rectX, rectY, width, height);

            // Draw contact symbol
            const symbol = instruction === 'XIC' ? '| |' : '|/|';
            ctx.font = 'bold 12px "Courier New", monospace';
            ctx.fillStyle = '#1f2937';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(symbol, x, y);

            // Add tag label with proper positioning - NEVER truncate
            if (tag) {
                ctx.font = '10px "Courier New", monospace';
                ctx.fillStyle = '#6b7280';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                const displayTag = tag; // ALWAYS show full tag name
                let tagX, tagY;
                if (element && element.branchType === 'parallel' && typeof element.splitX === 'number') {
                    tagX = element.splitX + 5; // 5px right of split
                } else {
                    tagX = Math.round(x - width/2 - 10); // fallback for non-parallel
                }
                tagY = Math.round(y + height/2 + 15); // 15px below element
                ctx.fillText(displayTag, tagX, tagY);
            }
        }

        function drawCoil(ctx, x, y, instruction, tag) {
            const radius = 18;
            
            // Draw coil circle
            ctx.strokeStyle = '#ea580c';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            // Draw coil symbol
            let symbol = '( )';
            if (instruction === 'OTL') symbol = '(L)';
            else if (instruction === 'OTU') symbol = '(U)';
            
            ctx.font = 'bold 12px "Courier New", monospace';
            ctx.fillStyle = '#1f2937';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(symbol, x, y);

            // Add tag label with proper positioning - NEVER truncate
            if (tag) {
                ctx.font = '10px "Courier New", monospace';
                ctx.fillStyle = '#6b7280';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                const displayTag = tag; // ALWAYS show full tag name
                // Position tag relative to element's actual position
                const tagY = Math.round(y + radius + 15); // 15px below element
                ctx.fillText(displayTag, x, tagY);
            }
        }

        function drawFunctionBlock(ctx, x, y, instruction, tag) {
            const width = 60;
            const height = 30;
            
            // Draw function block rectangle
            ctx.strokeStyle = '#7c3aed';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#ffffff';
            
            const rectX = Math.round(x - width/2);
            const rectY = Math.round(y - height/2);
            ctx.strokeRect(rectX, rectY, width, height);
            ctx.fillRect(rectX, rectY, width, height);
            ctx.strokeRect(rectX, rectY, width, height);

            // Draw instruction text
            ctx.font = 'bold 12px "Courier New", monospace';
            ctx.fillStyle = '#1f2937';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(instruction, x, y);

            // Add tag label with proper positioning - NEVER truncate
            if (tag) {
                ctx.font = '10px "Courier New", monospace';
                ctx.fillStyle = '#6b7280';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                const displayTag = tag; // ALWAYS show full tag name
                // Position tag relative to element's actual position
                const tagY = Math.round(y + height/2 + 15); // 15px below element
                ctx.fillText(displayTag, x, tagY);
            }
        }

        function getElementType(instruction) {
            if (['XIC', 'XIO'].includes(instruction)) return 'contact';
            if (['OTE', 'OTL', 'OTU'].includes(instruction)) return 'coil';
            return 'function';
        }

        function getElementWidth(instruction) {
            if (['XIC', 'XIO'].includes(instruction)) return 35;
            if (['OTE', 'OTL', 'OTU'].includes(instruction)) return 36; // diameter
            return 60;
        }

        function calculateElementWidth(instruction, tag) {
            const baseWidth = getElementWidth(instruction);
            const tagWidth = tag.length * 8; // Increased from 7 to 8 for better fit
            return Math.max(baseWidth + 20, tagWidth + 25); // Increased padding and minimum width
        }

        function getElementHeight(instruction) {
            if (['XIC', 'XIO'].includes(instruction)) return 25;
            if (['OTE', 'OTL', 'OTU'].includes(instruction)) return 36; // diameter
            return 30;
        }

        // Auto-run basic test on load
        window.onload = function() {
            log('Page loaded, ready for testing');
            log('Studio 5000 Ladder Logic Renderer - Production Ready');
            log('✅ Power rails: #10b981 green, 6px thick, x=20 and x=width-20');
            log('✅ Main connections: #6b7280 grey, 3px horizontal lines');
            log('✅ Branch connectors: #6b7280 grey, 2px dashed vertical lines');
            log('✅ Element colors: Blue contacts, orange coils, purple function blocks');
            log('✅ Font: "Courier New" monospace for professional appearance');
            log('✅ Element spacing: 40px horizontal between elements');
            log('✅ Branch spacing: 30px vertical between branches');
            log('✅ Pixel-perfect positioning with Math.round()');
        };
    </script>
</body>
</html> 