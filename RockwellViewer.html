<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Ladder Logic System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for a more polished look and feel */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* A slightly lighter gray */
        }
        .btn {
            @apply font-semibold py-3 px-5 rounded-lg shadow-md hover:shadow-lg transition-all duration-200 ease-in-out transform hover:-translate-y-0.5 focus:outline-none focus:ring-2 focus:ring-offset-2;
        }
        .btn-primary {
            @apply bg-blue-600 hover:bg-blue-700 text-white focus:ring-blue-500;
        }
        .btn-secondary {
            @apply bg-gray-500 hover:bg-gray-600 text-white focus:ring-gray-400;
        }
        .btn-active {
            @apply bg-blue-700 ring-2 ring-offset-2 ring-blue-500 shadow-inner scale-105 -translate-y-0.5;
        }
        #canvas-container {
            transition: height 0.3s ease-in-out;
            max-height: calc(100vh - 200px); /* Prevent growing beyond viewport */
            overflow: visible;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="min-h-screen flex flex-col">
        <header class="text-center p-4 bg-white shadow-lg flex-shrink-0">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800">Responsive Ladder Logic System</h1>
            <p class="text-gray-500 mt-1">A modern, responsive ladder logic renderer with a completely rebuilt and corrected wiring engine.</p>
        </header>

        <div class="flex-1 flex flex-col">
            <div class="bg-white shadow-lg flex-shrink-0">
                <div class="panel-header bg-gray-800 text-white p-4 flex justify-between items-center">
                    <h2 class="text-lg font-semibold">Ladder Logic Canvas</h2>
                </div>
                <div class="panel-content p-4">
                    <div id="button-container" class="button-group flex flex-wrap gap-3 mb-4">
                        <button class="btn btn-primary" data-testid="simple" onclick="app.runTest('simple')">Simple Rung</button>
                        <button class="btn btn-primary" data-testid="longLabels" onclick="app.runTest('longLabels')">Long Labels Test</button>
                        <button class="btn btn-primary" data-testid="complex" onclick="app.runTest('complex')">Standard Branch</button>
                        <button class="btn btn-primary" data-testid="longRung" onclick="app.runTest('longRung')">Long Rung Wrap</button>
                        <button class="btn btn-primary" data-testid="gsvMeqComplex" onclick="app.runTest('gsvMeqComplex')">Complex Branch (GSV/MEQ)</button>
                        <button class="btn btn-primary" data-testid="complexWrap" onclick="app.runTest('complexWrap')">Complex Wrap</button>
                        <button class="btn btn-primary" data-testid="zoomTest" onclick="app.runTest('zoomTest')">Zoom Test</button>
                        <button class="btn btn-secondary" onclick="app.clear()">Clear</button>
                    </div>
                </div>
            </div>
            
            <div id="canvas-container" class="flex-1 bg-gray-50 border-2 border-gray-200 overflow-hidden">
                <!-- Canvas will be inserted here by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            RUNG_V_SPACING: 100,      // Vertical spacing for wrapped lines
            RUNG_TOP_PADDING: 50,
            POWER_RAIL_WIDTH: 8,
            WIRE_WIDTH: 3,
            CONTACT_WIDTH: 40,
            CONTACT_HEIGHT: 30,
            INSTRUCTION_BOX_WIDTH: 280,
            INSTRUCTION_BOX_HEIGHT: 120,
            COMPARISON_WIDTH: 60,
            COIL_RADIUS: 20,
            ELEMENT_SPACING: 40,      // Horizontal spacing between elements
            MIN_TEXT_SPACING: 100,    // Minimum spacing to prevent text overlap
            BRANCH_V_SPACING: 60,     // Vertical spacing for paths within a branch
            RAIL_PADDING: 40,         // Horizontal padding from power rails
            SYMBOL_FONT: 'bold 14px "Courier New", monospace',
            LABEL_FONT: '12px "Courier New", monospace',
            COLORS: {
                RAIL: '#10b981',      // Green for power rails
                WIRE: '#374151',      // Dark gray for wires
                CONTACT_NO: '#1f2937',
                CONTACT_NC: '#1f2937',
                COIL: '#ea580c',      // Orange for coils
                TEXT: '#1f2937',
                TEXT_BG: 'rgba(255, 255, 255, 0.85)' // Slightly transparent white for label backgrounds
            }
        };

        // --- LADDER RENDERER CLASS ---
        class LadderRenderer {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                if (!this.container) throw new Error(`Container with id "${containerId}" not found.`);
                this.canvas = null;
                this.ctx = null;
                this.rungDefinition = null;
                this.resizeObserver = null;
            }

            // Initializes canvas and sets up responsive resizing
            initialize(rungDefinition) {
                this.rungDefinition = rungDefinition;
                this.container.innerHTML = '';
                this.canvas = document.createElement('canvas');
                this.container.appendChild(this.canvas);
                this.ctx = this.canvas.getContext('2d');
                
                if (this.resizeObserver) {
                    this.resizeObserver.disconnect();
                }
                
                // Add debounce to prevent rapid firing
                let resizeTimeout;
                this.resizeObserver = new ResizeObserver(() => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => this.redraw(), 10);
                });
                this.resizeObserver.observe(this.container);

                // Initial draw with a small delay to ensure container is stable
                setTimeout(() => this.redraw(), 50);
            }
            
            // --- SIMPLIFIED REDRAW FUNCTION ---
            redraw() {
                if (!this.rungDefinition || !this.container.offsetParent) return;
                const { width, height } = this.container.getBoundingClientRect();
                
                // Set canvas dimensions to match container
                this.canvas.width = width;
                this.canvas.height = height;

                // Calculate layout
                const { leftRailX, rightRailX } = this.getRailPositions();
                const tempRungDef = JSON.parse(JSON.stringify(this.rungDefinition));
                const positionedLayout = this.layoutElements(tempRungDef, leftRailX, rightRailX);
                const { rungTop, rungBottom } = this.getVerticalBounds(positionedLayout);
                
                // Check if content fits horizontally and adjust if needed
                const contentWidth = this.getContentWidth(positionedLayout);
                const availableWidth = width - 40; // Leave 20px padding on each side
                
                if (contentWidth > availableWidth) {
                    // Content is too wide, we need to adjust the layout
                    const scale = availableWidth / contentWidth;
                    this.scaleLayout(positionedLayout, scale);
                }
                
                // Clear and prepare canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
                
                // Center the content vertically in the available space
                const contentHeight = rungBottom - rungTop;
                const yOffset = -rungTop + (height - contentHeight) / 2;
                this.shiftLayout(positionedLayout, yOffset);
                
                // Drawing logic (order is critical)
                this.drawPowerRails(rungTop + yOffset, rungBottom + yOffset);
                this.drawWires(positionedLayout, leftRailX, rightRailX);
                
                positionedLayout.forEach((line, lineIndex) => {
                    const isLastLine = lineIndex === positionedLayout.length - 1;
                    line.elements.forEach((el, elIndex) => {
                        const isLastElementInRung = isLastLine && (elIndex === line.elements.length - 1);
                        this.drawElement(el, isLastElementInRung, rightRailX);
                    });
                });
            }
            
            drawElement(el, isLastElementInRung = false, rightRailX = 0) {
                switch (el.type) {
                    case 'NO_CONTACT': this.drawContact(el.x, el.y, el.label, 'NO', el); break;
                    case 'NC_CONTACT': this.drawContact(el.x, el.y, el.label, 'NC', el); break;
                    case 'OUTPUT_COIL': this.drawCoil(el.x, el.y, el.label, el); break;
                    case 'BRANCH': this.drawBranch(el, isLastElementInRung, rightRailX); break;
                    case 'INSTRUCTION_BOX': this.drawInstructionBox(el.x, el.y, el.label, el.instruction, el.params, el); break;
                    case 'COMPARISON': this.drawComparison(el.x, el.y, el.label, el.instruction, el); break;
                }
            }
            
            // --- CORRECTED LAYOUT ENGINE ---
            layoutElements(rungDefinition, leftRailX, rightRailX) {
                const lines = [];
                let currentLineElements = [];
                let xCursor = leftRailX + CONFIG.RAIL_PADDING;
                let currentY = 0; // Start at 0, will be shifted later

                rungDefinition.forEach(el => this.calculateElementDimensions(el));
                
                // Calculate the effective left rail position for layout purposes
                const leftRailConnectionX = leftRailX + CONFIG.POWER_RAIL_WIDTH / 2 + 5;
                const effectiveLeftRailX = leftRailConnectionX + CONFIG.ELEMENT_SPACING;
                
                // This loop now correctly calculates when to wrap.
                rungDefinition.forEach((el, index) => {
                    const elementEndPos = xCursor + el.elWidth;
                    
                    // Check if we need to wrap due to right rail proximity OR left rail proximity
                    if (currentLineElements.length > 0 && 
                        (elementEndPos > (rightRailX - CONFIG.RAIL_PADDING) || 
                         xCursor < effectiveLeftRailX)) {
                        lines.push({ elements: currentLineElements, y: currentY });
                        currentLineElements = [];
                        currentY += CONFIG.RUNG_V_SPACING;
                        xCursor = effectiveLeftRailX;
                    }
                    
                    currentLineElements.push(el);
                    
                    // Calculate optimal spacing to next element
                    const nextEl = rungDefinition[index + 1];
                    const spacing = this.calculateOptimalSpacing(el, nextEl);
                    xCursor += el.elWidth + spacing;
                });
                
                if (currentLineElements.length > 0 || lines.length === 0) {
                    lines.push({ elements: currentLineElements, y: currentY });
                }

                // Position all elements within their lines, handling final coil justification
                lines.forEach((line, lineIndex) => {
                    const isLastLine = lineIndex === lines.length - 1;
                    const lastElement = line.elements[line.elements.length - 1];
                    let coilToJustify = null;

                    if (isLastLine && lastElement && lastElement.type === 'OUTPUT_COIL') {
                        coilToJustify = line.elements.pop();
                    }

                    // Calculate proper starting position that accounts for text labels
                    const leftRailConnectionX = leftRailX + CONFIG.POWER_RAIL_WIDTH / 2 + 5;
                    let xPos = leftRailConnectionX + CONFIG.ELEMENT_SPACING;
                    
                    // For the first element, ensure there's enough space for its text label
                    if (line.elements.length > 0) {
                        const firstEl = line.elements[0];
                        const textPadding = Math.max(0, (firstEl.textWidth || 0) / 2 + 20); // Half text width plus padding
                        xPos = Math.max(xPos, leftRailConnectionX + textPadding);
                    }
                    
                    line.elements.forEach((el, index) => {
                        el.x = xPos + el.elWidth / 2;
                        el.y = line.y;
                        
                        // Calculate optimal spacing to next element based on text width
                        const nextEl = line.elements[index + 1];
                        const spacing = this.calculateOptimalSpacing(el, nextEl);
                        xPos += el.elWidth + spacing;
                    });

                    if (coilToJustify) {
                        // Ensure the coil has enough space for its text label
                        const textPadding = Math.max(0, (coilToJustify.textWidth || 0) / 2 + 20);
                        const coilX = rightRailX - CONFIG.RAIL_PADDING - textPadding - (coilToJustify.elWidth / 2);
                        coilToJustify.x = coilX;
                        coilToJustify.y = line.y;
                        line.elements.push(coilToJustify);
                    }
                });

                return lines;
            }

            calculateElementDimensions(el) {
                el.elHeight = CONFIG.CONTACT_HEIGHT; // Default height
                
                // Calculate text width for label if it exists
                let textWidth = 0;
                if (el.label) {
                    // Create a temporary canvas to measure text accurately
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.font = CONFIG.LABEL_FONT;
                    textWidth = tempCtx.measureText(el.label).width;
                }
                el.textWidth = textWidth;
                
                switch(el.type) {
                    case 'NO_CONTACT': case 'NC_CONTACT': 
                        el.elWidth = CONFIG.CONTACT_WIDTH; // Keep physical symbol width constant
                        break;
                    case 'COMPARISON': 
                        el.elWidth = CONFIG.COMPARISON_WIDTH;
                        break;
                    case 'OUTPUT_COIL': 
                        el.elWidth = CONFIG.COIL_RADIUS * 2;
                        el.elHeight = CONFIG.COIL_RADIUS * 2;
                        break;
                    case 'INSTRUCTION_BOX': 
                        el.elWidth = CONFIG.INSTRUCTION_BOX_WIDTH;
                        el.elHeight = CONFIG.INSTRUCTION_BOX_HEIGHT;
                        break;
                    case 'BRANCH':
                        let maxWidth = 0;
                        let totalHeight = 0;
                        
                        el.paths.forEach(path => {
                            let pathWidth = 0;
                            let pathMaxHeight = 0;
                            path.elements.forEach(subEl => {
                                this.calculateElementDimensions(subEl);
                                pathWidth += subEl.elWidth;
                                if(subEl.elHeight > pathMaxHeight) pathMaxHeight = subEl.elHeight;
                            });
                            // Calculate optimal spacing for elements in this path
                            for (let i = 0; i < path.elements.length - 1; i++) {
                                const spacing = this.calculateOptimalSpacing(path.elements[i], path.elements[i + 1]);
                                pathWidth += spacing;
                            }
                            
                            // Add extra padding for the path
                            pathWidth += CONFIG.ELEMENT_SPACING * 2;

                            if (pathWidth > maxWidth) maxWidth = pathWidth;
                            path.pathHeight = pathMaxHeight;
                            totalHeight += pathMaxHeight;
                        });
                        
                        totalHeight += (el.paths.length > 1 ? (el.paths.length - 1) * CONFIG.BRANCH_V_SPACING : 0);
                        el.elWidth = maxWidth + CONFIG.ELEMENT_SPACING * 4; // Add more padding for branch connectors
                        el.elHeight = totalHeight;
                        break;
                    default: el.elWidth = 0; break;
                }
            }

            // Calculate optimal spacing between two elements based on their text labels
            calculateOptimalSpacing(el1, el2) {
                if (!el1 || !el2) return CONFIG.MIN_TEXT_SPACING;
                
                // Get text widths
                const text1Width = el1.textWidth || 0;
                const text2Width = el2.textWidth || 0;
                
                // Calculate minimum spacing needed to prevent text overlap
                // Use the full text width, not just half, to ensure no overlap even with truncated text
                const minTextSpacing = Math.max(text1Width, text2Width) + 40; // Full text width plus padding
                
                // Return the maximum of minimum text spacing and default element spacing
                return Math.max(CONFIG.ELEMENT_SPACING, CONFIG.MIN_TEXT_SPACING, minTextSpacing);
            }

            getVerticalBounds(layout) {
                let rungTop = Infinity, rungBottom = -Infinity;
                if (layout.length === 0 || layout[0].elements.length === 0) return { rungTop: 0, rungBottom: 200 };
                
                layout.forEach(line => {
                    line.elements.forEach(el => {
                        const top = el.y - el.elHeight / 2 - 20; // Add buffer for labels
                        const bottom = el.y + el.elHeight / 2 + 20;
                        if (top < rungTop) rungTop = top;
                        if (bottom > rungBottom) rungBottom = bottom;
                    });
                });
                return { rungTop, rungBottom };
            }

            getContentWidth(layout) {
                if (layout.length === 0 || layout[0].elements.length === 0) return 0;
                
                let minX = Infinity, maxX = -Infinity;
                layout.forEach(line => {
                    line.elements.forEach(el => {
                        const left = el.x - el.elWidth / 2 - (el.textWidth || 0) / 2 - 20; // Include text width
                        const right = el.x + el.elWidth / 2 + (el.textWidth || 0) / 2 + 20;
                        if (left < minX) minX = left;
                        if (right > maxX) maxX = right;
                    });
                });
                
                return maxX - minX;
            }

            scaleLayout(layout, scale) {
                layout.forEach(line => {
                    line.elements.forEach(el => {
                        el.x *= scale;
                        el.elWidth *= scale;
                        el.elHeight *= scale;
                        if (el.textWidth) el.textWidth *= scale;
                        if (el.type === 'BRANCH') {
                            this.scaleBranch(el, scale);
                        }
                    });
                });
            }

            scaleBranch(branchEl, scale) {
                branchEl.paths.forEach(path => {
                    path.elements.forEach(el => {
                        el.x *= scale;
                        el.elWidth *= scale;
                        el.elHeight *= scale;
                        if (el.textWidth) el.textWidth *= scale;
                        if (el.type === 'BRANCH') {
                            this.scaleBranch(el, scale);
                        }
                    });
                });
            }

            shiftLayout(layout, yOffset) {
                layout.forEach(line => {
                    line.y += yOffset;
                    line.elements.forEach(el => {
                        el.y += yOffset;
                        if(el.type === 'BRANCH') {
                           this.shiftBranch(el, yOffset);
                        }
                    });
                });
            }

            shiftBranch(branchEl, yOffset){
                branchEl.paths.forEach(path => {
                    path.elements.forEach(el => {
                        el.y += yOffset;
                        if(el.type === 'BRANCH') this.shiftBranch(el, yOffset);
                    });
                });
            }
            
            getRailPositions() {
                const leftRailX = CONFIG.POWER_RAIL_WIDTH / 2 + 40; // Increased padding for text labels
                const rightRailX = this.canvas.width - (CONFIG.POWER_RAIL_WIDTH / 2) - 40; // Increased padding for text labels
                return { leftRailX, rightRailX };
            }

            drawPowerRails(contentTop, contentBottom) {
                const { leftRailX, rightRailX } = this.getRailPositions();
                this.ctx.strokeStyle = CONFIG.COLORS.RAIL;
                this.ctx.lineWidth = CONFIG.POWER_RAIL_WIDTH;
                this.ctx.lineCap = 'round';
                
                // Add some padding above and below the content for the rails
                const railTop = Math.max(0, contentTop - 20);
                const railBottom = Math.min(this.canvas.height, contentBottom + 20);
                
                this.ctx.beginPath();
                this.ctx.moveTo(leftRailX, railTop);
                this.ctx.lineTo(leftRailX, railBottom);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.moveTo(rightRailX, railTop);
                this.ctx.lineTo(rightRailX, railBottom);
                this.ctx.stroke();
            }

            drawWires(lines, leftRailX, rightRailX) {
                if (lines.length === 0 || lines[0].elements.length === 0) return;

                this.ctx.strokeStyle = CONFIG.COLORS.WIRE;
                this.ctx.lineWidth = CONFIG.WIRE_WIDTH;
                this.ctx.lineCap = 'butt';

                lines.forEach(line => {
                    for (let i = 0; i < line.elements.length - 1; i++) {
                        const currentEl = line.elements[i];
                        const nextEl = line.elements[i + 1];
                        this.ctx.beginPath();
                        this.ctx.moveTo(currentEl.x + currentEl.elWidth / 2 + 5, currentEl.y); // Add 5px padding
                        this.ctx.lineTo(nextEl.x - nextEl.elWidth / 2 - 5, nextEl.y); // Add 5px padding
                        this.ctx.stroke();
                    }
                });

                // Draw left rail connection with proper spacing consideration
                const firstEl = lines[0].elements[0];
                const leftRailConnectionX = leftRailX + CONFIG.POWER_RAIL_WIDTH / 2 + 5; // Add small gap from rail
                this.ctx.beginPath();
                this.ctx.moveTo(leftRailConnectionX, firstEl.y);
                this.ctx.lineTo(firstEl.x - firstEl.elWidth / 2 - 5, firstEl.y); // Add 5px padding
                this.ctx.stroke();
                
                const lastLine = lines[lines.length - 1];
                const lastEl = lastLine.elements[lastLine.elements.length - 1];
                if (lastEl.type !== 'BRANCH') {
                    this.ctx.beginPath();
                    this.ctx.moveTo(lastEl.x + lastEl.elWidth / 2 + 5, lastEl.y); // Add 5px padding
                    this.ctx.lineTo(rightRailX, lastEl.y);
                    this.ctx.stroke();
                }

                for (let i = 0; i < lines.length - 1; i++) {
                    const endOfCurrentLine = lines[i].elements[lines[i].elements.length - 1];
                    const startOfNextLine = lines[i + 1].elements[0];
                    if (!endOfCurrentLine || !startOfNextLine) continue;

                    const transferY = endOfCurrentLine.y + (CONFIG.RUNG_V_SPACING / 2);

                    this.ctx.beginPath();
                    this.ctx.moveTo(endOfCurrentLine.x + endOfCurrentLine.elWidth / 2 + 5, endOfCurrentLine.y); // Add 5px padding
                    this.ctx.lineTo(rightRailX, endOfCurrentLine.y);
                    this.ctx.lineTo(rightRailX, transferY);
                    this.ctx.lineTo(leftRailX, transferY);
                    this.ctx.lineTo(leftRailX, startOfNextLine.y);
                    this.ctx.lineTo(startOfNextLine.x - startOfNextLine.elWidth / 2 - 5, startOfNextLine.y); // Add 5px padding
                    this.ctx.stroke();
                }
            }

            drawTextAboveSymbol(text, x, y, el) {
                if (!text) return;
                
                this.ctx.font = CONFIG.LABEL_FONT;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'bottom';
                
                // Display the full text without truncation
                let displayText = text;
                let textMetrics = this.ctx.measureText(displayText);
                
                const textHeight = 14; 
                const textY = y - (el.elHeight / 2) - 8; 
                
                // Draw background with proper width
                this.ctx.fillStyle = CONFIG.COLORS.TEXT_BG;
                this.ctx.fillRect(x - textMetrics.width / 2 - 4, textY - textHeight, textMetrics.width + 8, textHeight + 4);
                
                // Draw text
                this.ctx.fillStyle = CONFIG.COLORS.TEXT;
                this.ctx.fillText(displayText, x, textY);
            }

            drawContact(x, y, label, type, el) {
                this.drawTextAboveSymbol(label, x, y, el);
                this.ctx.strokeStyle = type === 'NC' ? CONFIG.COLORS.CONTACT_NC : CONFIG.COLORS.CONTACT_NO;
                this.ctx.lineWidth = 2.5;
                this.ctx.font = CONFIG.SYMBOL_FONT;
                this.ctx.fillStyle = CONFIG.COLORS.CONTACT_NO;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(type === 'NC' ? '|/|' : '| |', x, y);
            }

            drawComparison(x, y, label, text, el) {
                this.drawTextAboveSymbol(label, x, y, el);
                this.ctx.strokeStyle = CONFIG.COLORS.CONTACT_NO;
                this.ctx.lineWidth = 2.5;
                this.ctx.font = CONFIG.SYMBOL_FONT;
                this.ctx.fillStyle = CONFIG.COLORS.TEXT;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(`[ ${text} ]`, x, y);
            }

            drawInstructionBox(x, y, label, instruction, params = {}, el) {
                this.drawTextAboveSymbol(label, x, y, el);
                const w = el.elWidth;
                const h = el.elHeight;
                
                this.ctx.strokeStyle = CONFIG.COLORS.WIRE;
                this.ctx.lineWidth = 2.5;
                this.ctx.fillStyle = 'white';
                this.ctx.strokeRect(x - w / 2, y - h / 2, w, h);
                
                this.ctx.fillStyle = CONFIG.COLORS.TEXT;
                this.ctx.textAlign = 'center';
                this.ctx.font = 'bold 14px "Courier New", monospace';
                this.ctx.fillText(instruction, x, y - h/2 + 20);
                
                this.ctx.font = '12px "Courier New", monospace';
                this.ctx.textAlign = 'left';
                let paramY = y - h/2 + 45;
                for (const [key, value] of Object.entries(params)) {
                    this.ctx.fillText(`${key}: ${value}`, x - w/2 + 10, paramY);
                    paramY += 20;
                }
            }

            drawCoil(x, y, label, el) {
                const r = CONFIG.COIL_RADIUS;
                this.drawTextAboveSymbol(label, x, y, el);
                this.ctx.strokeStyle = CONFIG.COLORS.COIL;
                this.ctx.lineWidth = 2.5;
                this.ctx.fillStyle = 'white';
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, r, 0, 2 * Math.PI);
                this.ctx.stroke();
                
                this.ctx.font = CONFIG.SYMBOL_FONT;
                this.ctx.fillStyle = CONFIG.COLORS.TEXT;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('( )', x, y);
            }

            drawBranch(branchEl, isLastElementInRung = false, rightRailX = 0) {
                const { x, y, elWidth, elHeight, paths } = branchEl;
                const branchStartX = x - elWidth / 2;
                const internalBranchEndX = x + elWidth / 2;
                
                console.log('Drawing branch:', {
                    x, y, elWidth, elHeight,
                    branchStartX, internalBranchEndX,
                    paths: paths.map(p => ({ elements: p.elements.map(e => e.label) }))
                });
                
                let startY = y - elHeight / 2;

                const topPathCenterY = startY + paths[0].pathHeight / 2;
                const bottomPathCenterY = startY + elHeight - paths[paths.length-1].pathHeight / 2;

                this.ctx.strokeStyle = CONFIG.COLORS.WIRE;
                this.ctx.lineWidth = CONFIG.WIRE_WIDTH;
                this.ctx.beginPath();
                this.ctx.moveTo(branchStartX, topPathCenterY);
                this.ctx.lineTo(branchStartX, bottomPathCenterY);
                this.ctx.stroke();

                if (!isLastElementInRung) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(internalBranchEndX, topPathCenterY);
                    this.ctx.lineTo(internalBranchEndX, bottomPathCenterY);
                    this.ctx.stroke();
                }

                paths.forEach(path => {
                    const pathY = startY + path.pathHeight / 2;
                    let currentXInPath = branchStartX;

                    // Draw all elements in this path sequentially
                    path.elements.forEach((element, index) => {
                        // Calculate optimal spacing to this element
                        const prevElement = index > 0 ? path.elements[index - 1] : null;
                        const spacing = this.calculateOptimalSpacing(prevElement, element);
                        const elementX = currentXInPath + spacing + element.elWidth / 2;
                        
                        // Draw wire to this element
                        this.ctx.beginPath();
                        this.ctx.moveTo(currentXInPath, pathY);
                        this.ctx.lineTo(elementX - element.elWidth / 2 - 5, pathY);
                        this.ctx.stroke();
                        
                        // Draw the element itself
                        this.drawElement({ ...element, x: elementX, y: pathY });
                        
                        // Reset stroke style and update position
                        this.ctx.strokeStyle = CONFIG.COLORS.WIRE;
                        currentXInPath = elementX + element.elWidth / 2 + 5;
                    });

                    // Connect to the end of the branch
                    const finalEndX = isLastElementInRung ? rightRailX : internalBranchEndX;
                    this.ctx.beginPath();
                    this.ctx.moveTo(currentXInPath, pathY);
                    this.ctx.lineTo(finalEndX, pathY);
                    this.ctx.stroke();
                    
                    startY += path.pathHeight + CONFIG.BRANCH_V_SPACING;
                });
            }
            
            destroy() {
                if (this.resizeObserver && this.container) {
                    this.resizeObserver.disconnect();
                    this.resizeObserver = null;
                }
                if (this.container) this.container.innerHTML = '';
            }
        }

        // --- APPLICATION LOGIC ---
        const app = {
            renderer: new LadderRenderer('canvas-container'),
            activeTest: null,
            
            rungDefs: {
                simple: [
                    { type: 'NO_CONTACT', label: 'Start_Button' },
                    { type: 'NC_CONTACT', label: 'Stop_Button' },
                    { type: 'OUTPUT_COIL', label: 'Motor_Output' }
                ],
                longLabels: [
                    { type: 'NO_CONTACT', label: 'Very_Long_Start_Button_Label_That_Should_Not_Overlap' },
                    { type: 'NC_CONTACT', label: 'Another_Very_Long_Stop_Button_Label_For_Testing' },
                    { type: 'OUTPUT_COIL', label: 'Motor_Output_With_Long_Label_Too' }
                ],
                complex: [
                    { type: 'NO_CONTACT', label: 'Start_Button' },
                    { type: 'NC_CONTACT', label: 'Stop_Button' },
                    { 
                        type: 'BRANCH', 
                        paths: [
                            { elements: [{ type: 'NO_CONTACT', label: 'Limit_Switch' }, { type: 'NO_CONTACT', label: 'Photo_Eye' }] },
                            { elements: [{ type: 'NO_CONTACT', label: 'Pressure_Switch' }] }
                        ]
                    },
                    { type: 'OUTPUT_COIL', label: 'Motor_Output' }
                ],
                longRung: [
                    { type: 'NO_CONTACT', label: 'Input_A' }, { type: 'NO_CONTACT', label: 'Input_B' },
                    { type: 'NC_CONTACT', label: 'Input_C' }, { type: 'NO_CONTACT', label: 'Input_D' },
                    { type: 'NO_CONTACT', label: 'Input_E' }, { type: 'NC_CONTACT', label: 'Input_F' },
                    { type: 'NO_CONTACT', label: 'Input_G' }, { type: 'NC_CONTACT', label: 'Input_H' },
                    { type: 'OUTPUT_COIL', label: 'Long_Rung_Coil' }
                ],
                gsvMeqComplex: [
                    {
                        type: 'INSTRUCTION_BOX',
                        instruction: 'GSV',
                        params: {
                            'Class': 'Module',
                            'Instance': 'S100FX1PMN1',
                            'Attribute': 'EntryStatus',
                            'Dest': 'S100FX1PMN1.M.ObjectStatus'
                        }
                    },
                    {
                        type: 'BRANCH',
                        paths: [
                            {
                                elements: [
                                    {
                                        type: 'INSTRUCTION_BOX', instruction: 'MEQ',
                                        params: { 'Source': 'S100FX1PMN1.M.ObjectStatus', 'Mask': '16#F000', 'Compare': '16#6000' }
                                    },
                                    { type: 'OUTPUT_COIL', label: 'S100FX1PMN1.M.Inhibited' }
                                ]
                            },
                            {
                                elements: [
                                    {
                                        type: 'INSTRUCTION_BOX', instruction: 'MEQ',
                                        params: { 'Source': 'S100FX1PMN1.M.ObjectStatus', 'Mask': '16#F000', 'Compare': '16#4000' }
                                    },
                                    { type: 'OUTPUT_COIL', label: 'S100FX1PMN1.M.CommOk' }
                                ]
                            }
                        ]
                    }
                ],
                complexWrap: [
                    { type: 'NO_CONTACT', label: 'System_Enable' },
                    { type: 'NO_CONTACT', label: 'Auto_Mode' },
                    {
                        type: 'BRANCH',
                        paths: [
                            { elements: [
                                { type: 'NO_CONTACT', label: 'Path_A_Sensor_1' },
                                { type: 'NC_CONTACT', label: 'Path_A_Sensor_2' },
                                { type: 'NO_CONTACT', label: 'Path_A_Sensor_3' }
                            ]},
                            { elements: [
                                { type: 'NO_CONTACT', label: 'Path_B_Sensor_1' },
                                { type: 'NO_CONTACT', label: 'Path_B_Sensor_2' }
                            ]}
                        ]
                    },
                    { type: 'NO_CONTACT', label: 'Another_Condition' },
                    { type: 'NC_CONTACT', label: 'Yet_Another_Condition' },
                    { type: 'NO_CONTACT', label: 'Final_Input_Before_Coil'},
                    { type: 'OUTPUT_COIL', label: 'Complex_Wrapped_Output' }
                ],
                zoomTest: [
                    { type: 'NO_CONTACT', label: 'A' },
                    { type: 'NO_CONTACT', label: 'B' },
                    { type: 'NO_CONTACT', label: 'C' },
                    { type: 'NO_CONTACT', label: 'D' },
                    { type: 'NO_CONTACT', label: 'E' },
                    { type: 'NO_CONTACT', label: 'F' },
                    { type: 'NO_CONTACT', label: 'G' },
                    { type: 'NO_CONTACT', label: 'H' },
                    { type: 'NO_CONTACT', label: 'I' },
                    { type: 'NO_CONTACT', label: 'J' },
                    { type: 'NO_CONTACT', label: 'K' },
                    { type: 'NO_CONTACT', label: 'L' },
                    { type: 'NO_CONTACT', label: 'M' },
                    { type: 'NO_CONTACT', label: 'N' },
                    { type: 'NO_CONTACT', label: 'O' },
                    { type: 'NO_CONTACT', label: 'P' },
                    { type: 'OUTPUT_COIL', label: 'Zoom_Test_Coil' }
                ]
            },

            runTest(testName) {
                this.activeTest = testName;
                if (this.rungDefs[testName]) {
                    console.log('Running test:', testName, 'at', new Date().toISOString());
                    console.log('Test data:', JSON.stringify(this.rungDefs[testName], null, 2));
                    this.renderer.initialize(this.rungDefs[testName]);
                }
                this.updateButtonStyles();
            },

            clear() {
                this.activeTest = null;
                this.renderer.destroy();
                this.updateButtonStyles();
            },

            updateButtonStyles() {
                const buttons = document.querySelectorAll('#button-container .btn-primary');
                buttons.forEach(button => {
                    if (button.dataset.testid === this.activeTest) {
                        button.classList.add('btn-active');
                    } else {
                        button.classList.remove('btn-active');
                    }
                });
            },

            init() {
                // Set an initial test case to display on load
                this.runTest('simple'); 
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            app.init();
        });

    </script>
</body>
</html>